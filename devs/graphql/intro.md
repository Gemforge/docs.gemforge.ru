# Архитектура Gemforge (Lending, Topus)

В этой документации я постараюсь кратко описать, какая арихитектура используется для наших проектов, какие основные технологии мы используем и как конкретно мы делаем те или иные вещи с примерами кода.

Цель этой документации, чтобы можно было быстро найти подход для решения задачи в рамках проекта и быстро найти примеры.

- [Архитектура Gemforge (Lending, Topus)](#архитектура-gemforge-lending-topus)
  - [Общая архитектура](#общая-архитектура)
    - [Слой доступа к данным (DAL)](#слой-доступа-к-данным-dal)
    - [API Layer](#api-layer)
    - [UI](#ui)
  - [GraphQL](#graphql)
    - [Schema - граф данных](#schema---граф-данных)
    - [Типы данных](#типы-данных)
    - [Запросы](#запросы)
    - [Мутации](#мутации)
  - [Apollo Server](#apollo-server)
  - [Apollo Client](#apollo-client)
  - [Аутентификация и Авторизация](#аутентификация-и-авторизация)

## Общая архитектура

В основе всех приложений (Лендинга и Топуса) стоит одна и та же архитектура. Сделано это специально, чтобы можно было делать разные приложения не сильно меняя подход и управлять всеми данными в одном месте.

По сути мы имеем три классических слоя:
- Data Access Layer (DAL)
- API Layer (API)
- UI

### Слой доступа к данным (DAL)

В этом слое мы управляем данными на уровне хранения в базе. Делается это с помощью абстракции называемой `Object-Relationship Mapping (ORM)`, которая позволяет описывать модель данных не привязываясь к конкретной `СУБД (Система Управления Базами Данных, или просто База Данных)`

В нашем случае СУБД является `MySql`. Это бесплатная СУБД, которая используется миллионами сайтов по всему миру.

Технология `ORM` которую мы выбрали называется [`prisma.io`](https://prisma.io) - это ORM которая поддерживает `Javascript` и `Typescript` для запросов к выбранной базе. Сама по себе призма сделана на более низкоуровневом языке и ее ядро достаточно быстрое.

`Prisma` состоит из нескольких частей:
- Схема, описывается в файле `prisma.schema`. Язык описание похож на `GraphQL` но это отдельный диалект. В схеме описываются таблицы, связи и дополнительные метаданные, которые помогают сгенерировать `SQL` для нужной СУБД
- Клиент - это типизированный класс (`PrismaClient`), которые генерируется на основе схемы и сожержить классы и методы для доступа к данным, так называемые `CRUD (Create, Retrieve, Update, Delete)` операции. Всё то, что курильщики (без ORM) делают руками через паттерны `Repository` и кучу `SQL` запросов.
- Миграции - это механизм обновления и отслеживания состояния базы данных. По сути миграции это такой `git` для базы данных.

> Интересно, что в ранних версиях Prisma (до 2.0), там действительно был GraphQL и стратегия была направлена на то, чтобы использовать одну спецификацию для доступа к данным и API. Но со временем стало ясно, что Data Access и API сильно разные задачи.

#### Правила

Изменения в базе очень критический момент, т.к. может привести к потере данных или сбою работы всех приложений. Поэтому важно очень тщательно подходить к этой задаче и придерживаться нескольких правил:
- Работать с локальной базой, пока модель данных не стабилизирована, чтобы избежать множества обновлений.
- Проверять все миграции на Тестовой базе, т.к. иногда `Prisma` может сгенерировать неправильные имена, что вызове сбой `SQL` скрипта
- Обновлять все базы до свежей версии модели

> В будущем обновление должно быть автоматическим через CI pipeline

### API Layer

API уровень - это как наш `Backend (BE)` общается в `Frontend (FE)`. Другими словами, как наши веб-приложения получают и записывают данные с сервера.

Существует множество технологий для создания API слоев. Исторически были популярны различные модели удаленного вызова процедур (`Remote Procedure Call`). Когда появился протокол `HTTP` стало популярно делать API через этот протокол. Сегодя почти все что делается через `HTTP` называют `REST (REpresentative State Transfer)`, хотя API которое сделано через `GET` и `POST` само по себе не становиться `REST`, но это уже лирика.

В общем `REST` имеет множество недостатков, несмотря на то что его легко и быстро делать поначалу, уже через несколько месяцев такие API становятся очень громоздкими и даже технологии типа `Swagger` которые автоматически генерируют документацию и тестовые страницы - не помогают легко манипулировать данными.

Я описывал в статье в нашем блоге, про то, почему стоит использовать `GraphQL`

В общем мы делаем практически весь API через единый граф данных.

> Стоит отметить, что DAL и API не сильно сцеплены, это позволяет использовать их независимо, тестировать отдельно. Также API может использовать не только DAL prisma, но и перенаправлять запросы на другие сервисы или загружать данные из файлов.

Есть несколько исключений:
- Аутентификация сделана через HTTP, чтобы не перенагружать веб приложения с клиентом GraphQL для первичной аутентификации. Но graphql поддерживает авторизацию через JWT токен и может контролировать доступ к ресурсам используя роли. Больше об этом в отдельной теме
- Загрузка и скачивание изображений - сделано через `HTTP` и `AWS S3` клиент. GraphQL не поддерживает по умолчанию загрузку файлом и делать ее через граф слишком накладно, да и не имеет особого смысла, т.к. файлы не являются частью графа, а вот пути к ним - да.

> Оба слоя DAL и API находятся в проекте `gemforge-api` и развертывается как единый контейнер.

### UI

Под слоем `UI` мы подразумевает все приложения которые используют API. Причем это не зависит от того, чисто клиентские или серверные приложения.

Например `Next.js` приложения будут использовать сервер.

А те что написаны на `Vite` - они просто статические файлы и все делается на стороне браузера.

## GraphQL

Для начала давайте вспомним, что же такое GraphQL. Если коротко и по сути - то это спецификации от компнии Facebook, для взяимодействия между клиентом и сервером. Спецификация описывает две основные технологии:
- Схема графа
- Язык запросов

### Schema - граф данных

Под `схемой` подразумевается набор всех поддерживаемых типов данных и запросов к ним.

Сами данные могут быть следующих типов:
- Скаляры (единичные типы, как `String`, `Int`, `Float`, `Boolean`)
- Объекты
- Массивы
- Скаляры-расширения (собственные типы, не входяшие в спецификацию)

Обычно схема описывается в виде набора файлов с расширением `.graphql`

> Интересно: тип данных `Date` не входит в спецификацию и описывается как отдельных скаляр-расширение для схемы. Это связано с тем, что `GraphQL` не привязана к конкретной реализации или языку программирования, а даты очень сильно отличаются в разных средах.

В схеме описывают следующие сущности:

### Типы данных

`Типы данных` - это то, что нам будет возвращаться с сервера. Обычно это объекты состоящие из скаляров, массивов и других объектов. Пример:

```graphql
type Animal {
  id ID!
  name String!
  age Int
  owner Human
}
```

> `ID` - это специальный тип, который является строкой, но используется различными инструментами, чтобы правильно определять объект и кэшировать его.

### Запросы

`Запросы` - это то, как клиент может запрашивать данные. Запросы могут быть как без параметров, так и параметризированные. Все запросы описываются в типе данных `Query`

> Заметьте, что в проекте может быть несколько файлов `*.graphql` и каждый будет содержать объект `Query`. На самом деле в схеме только один объект такого типа, который описывает все запросы, просто во время сборки все файлы будут склеены и все запросы будут слиты в один тип.

Примеры:
```
type Query {
  animal: [Aminal]
  animalByAge(age: Int!): [Animal]
}
```

Первый запрос `animal: [Animal]` возвращает список объектов типа `Animal` и не принимает никаких параметров.

Второй запрос `animalByAge(age: Int!): [Animal]` принимает один обязательный (помечен как `!`) параметр типа `Int` и также возвращает список объектов типа `Animal`

Важно заметить, что схема не содержим какуюто бизнес логику, оба запроса могут возвращать одно и тоже. Логика будет реализована в `резолверах`, о которых поговорим позже.

### Мутации

`Мутации` - это то, как мы можем менять данные. Так же как и запросы, мутации описываются в специальном типе схеме, который один на всю схему.

Пример:
```
input AnimalInput {
  name: String
  age: Int
}

type Mutation {
  addAnimal(input: AnimalInput): Animal
}
```

В этом примере важно запомнить несколько вещей:
- Одной из стандарнтых практик - это возвращать новый или измененный объект как результат мутации, таким образом кэш на стороне клиента будет обновляться автоматически.
- Если параметров несколько, то желательно создать отдельный тип данных для входных параметром, он создается через ключевое слово `input`


## Apollo Server

## Apollo Client

## Аутентификация и Авторизация
